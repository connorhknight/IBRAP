}
object@sample_metadata <- cbind(object@sample_metadata, enriched)
cat(crayon::cyan(paste0(Sys.time(), ': gene set enrichment analysis complete \n')))
return(object)
} else {
return(enriched)
}
}
perform.gsea <- function(object, gene.sets=escape::getGeneSets(library = 'H'), return_object=T) {
if(!is(object = object, class2 = 'IBRAP')) {
stop('Object must be of class IBRAP\n')
}
if(isFALSE(is(gene.sets, 'GeneSetCollection')) && isFALSE(is.list(gene.sets))) {
stop('gene.sets must be either GeneSetCollection or list object \n')
}
cat(crayon::cyan(paste0(Sys.time(), ': initiating gene set enrichment analysis \n')))
print(gene.sets)
enriched <- enrichIt(obj = object[[assay]]@counts, gene.sets = gene.sets, groups = 1000, cores = 3)
if(isTRUE(return_object)) {
for(o in names(enriched)) {
if(o %in% names(object@sample_metadata)) {
if(isTRUE(verbose)) {
cat(crayon::cyan(paste0('found duplicated column name: ',o, 'removing old column names.\n')))
}
object@sample_metadata[,o] <- NULL
}
}
object@sample_metadata <- cbind(object@sample_metadata, enriched)
cat(crayon::cyan(paste0(Sys.time(), ': gene set enrichment analysis complete \n')))
return(object)
} else {
return(enriched)
}
}
perform.gsea(object = obj)
enriched <- enrichIt(obj = object[[1]]@counts, gene.sets = gene.sets, groups = 1000, cores = 3)
perform.gsea <- function(object, gene.sets=escape::getGeneSets(library = 'H'), return_object=T) {
if(!is(object = object, class2 = 'IBRAP')) {
stop('Object must be of class IBRAP\n')
}
if(isFALSE(is(gene.sets, 'GeneSetCollection')) && isFALSE(is.list(gene.sets))) {
stop('gene.sets must be either GeneSetCollection or list object \n')
}
cat(crayon::cyan(paste0(Sys.time(), ': initiating gene set enrichment analysis \n')))
print(gene.sets)
enriched <- enrichIt(obj = object[[1]]@counts, gene.sets = gene.sets, groups = 1000, cores = 3)
if(isTRUE(return_object)) {
for(o in names(enriched)) {
if(o %in% names(object@sample_metadata)) {
if(isTRUE(verbose)) {
cat(crayon::cyan(paste0('found duplicated column name: ',o, 'removing old column names.\n')))
}
object@sample_metadata[,o] <- NULL
}
}
object@sample_metadata <- cbind(object@sample_metadata, enriched)
cat(crayon::cyan(paste0(Sys.time(), ': gene set enrichment analysis complete \n')))
return(object)
} else {
return(enriched)
}
}
enriched <- enrichIt(obj = object[[1]]@counts, gene.sets = gene.sets, groups = 1000, cores = 3)
object[[1]]
perform.gsea <- function(object, gene.sets=escape::getGeneSets(library = 'H'), return_object=T) {
if(!is(object = object, class2 = 'IBRAP')) {
stop('Object must be of class IBRAP\n')
}
if(isFALSE(is(gene.sets, 'GeneSetCollection')) && isFALSE(is.list(gene.sets))) {
stop('gene.sets must be either GeneSetCollection or list object \n')
}
cat(crayon::cyan(paste0(Sys.time(), ': initiating gene set enrichment analysis \n')))
print(gene.sets)
enriched <- enrichIt(obj = object@methods[[1]]@counts, gene.sets = gene.sets, groups = 1000, cores = 3)
if(isTRUE(return_object)) {
for(o in names(enriched)) {
if(o %in% names(object@sample_metadata)) {
if(isTRUE(verbose)) {
cat(crayon::cyan(paste0('found duplicated column name: ',o, 'removing old column names.\n')))
}
object@sample_metadata[,o] <- NULL
}
}
object@sample_metadata <- cbind(object@sample_metadata, enriched)
cat(crayon::cyan(paste0(Sys.time(), ': gene set enrichment analysis complete \n')))
return(object)
} else {
return(enriched)
}
}
perform.gsea(object = obj)
object@methods[[1]]@counts
perform.gsea <- function(object, gene.sets=escape::getGeneSets(library = 'H'), groups = 1000, cores = 1, return_object=T) {
if(!is(object = object, class2 = 'IBRAP')) {
stop('Object must be of class IBRAP\n')
}
if(isFALSE(is(gene.sets, 'GeneSetCollection')) && isFALSE(is.list(gene.sets))) {
stop('gene.sets must be either GeneSetCollection or list object \n')
}
cat(crayon::cyan(paste0(Sys.time(), ': initiating gene set enrichment analysis \n')))
print(gene.sets)
enriched <- enrichIt(obj = object@methods[[1]]@counts, gene.sets = gene.sets, groups = groups, cores = cores)
if(isTRUE(return_object)) {
for(o in names(enriched)) {
if(o %in% names(object@sample_metadata)) {
if(isTRUE(verbose)) {
cat(crayon::cyan(paste0('found duplicated column name: ',o, 'removing old column names.\n')))
}
object@sample_metadata[,o] <- NULL
}
}
object@sample_metadata <- cbind(object@sample_metadata, enriched)
cat(crayon::cyan(paste0(Sys.time(), ': gene set enrichment analysis complete \n')))
return(object)
} else {
return(enriched)
}
}
perform.gsea(object = obj)
perform.gsea <- function(object, gene.sets=escape::getGeneSets(library = 'H'), groups = 1000, cores = 1, return_object=T) {
if(!is(object = object, class2 = 'IBRAP')) {
stop('Object must be of class IBRAP\n')
}
if(isFALSE(is(gene.sets, 'GeneSetCollection')) && isFALSE(is.list(gene.sets))) {
stop('gene.sets must be either GeneSetCollection or list object \n')
}
cat(crayon::cyan(paste0(Sys.time(), ': initiating gene set enrichment analysis \n')))
print(gene.sets)
enriched <- enrichIt(obj = as_matrix(object@methods[[1]]@counts), gene.sets = gene.sets, groups = groups, cores = cores)
if(isTRUE(return_object)) {
for(o in names(enriched)) {
if(o %in% names(object@sample_metadata)) {
if(isTRUE(verbose)) {
cat(crayon::cyan(paste0('found duplicated column name: ',o, 'removing old column names.\n')))
}
object@sample_metadata[,o] <- NULL
}
}
object@sample_metadata <- cbind(object@sample_metadata, enriched)
cat(crayon::cyan(paste0(Sys.time(), ': gene set enrichment analysis complete \n')))
return(object)
} else {
return(enriched)
}
}
perform.gsea(object = obj)
genes <- perform.gsea(object = obj, cores = 3)
BiocManager::install("scTensor")
browseVignettes("scTensor")
devtools::install_github("sqjin/CellChat")
devtools::install_github("arc85/celltalker")
seuobj <- Seurat::CreateSeuratObject(counts = obj@methods$RAW@counts)
obj@sample_metadata$all_individual_samples.celseq.sample_metadata.celltype
seuobj$CellType <- obj@sample_metadata$all_individual_samples.celseq.sample_metadata.celltype
library()
library(CellChat)
seuobj@assays$RNA@data <- Seurat::LogNormalize(data = seuobj@assays$RNA@counts)
results <- celltalker::celltalk(input_object=seuobj, metadata_grouping = 'CellType', ligand_receptor_pairs = celltalker::ramilowski_pairs,
number_cells_required = 100, min_expression = 1000, max_expression = 20000, 10)
results
top_stats <- results %>%
mutate(fdr=p.adjust(p_val,method="fdr")) %>%
filter(fdr<0.05) %>%
group_by(cell_type1) %>%
top_n(3,interact_ratio) %>%
ungroup()
colors_use <- RColorBrewer::brewer.pal(n=length(unique(seuobj$cell_types)),"Set2")
colors_use <- RColorBrewer::brewer.pal(n=length(unique(seuobj$CellType)),"Set2")
colors_use <- RColorBrewer::brewer.pal(n=length(unique(seuobj$CellType)),"Set3")
colors_use <- RColorBrewer::brewer.pal(n=length(unique(seuobj$CellType)),"Set4")
colors_use <- RColorBrewer::brewer.pal(n=length(unique(seuobj$CellType)),"Set3")
scales::hue_pal()(length(unique(seuobj$CellType)))
colors_use <- scales::hue_pal()(length(unique(seuobj$CellType)))
circos_plot(ligand_receptor_frame=top_stats,
cell_group_colors=colors_use,
ligand_color="blue",
receptor_color="red",
cex_outer=0.5,
cex_inner=0.4)
celltalker::circos_plot(ligand_receptor_frame=top_stats,
cell_group_colors=colors_use,
ligand_color="blue",
receptor_color="red",
cex_outer=0.5,
cex_inner=0.4)
library(tidyverse)
celltalker::circos_plot(ligand_receptor_frame=top_stats,
cell_group_colors=colors_use,
ligand_color="blue",
receptor_color="red",
cex_outer=0.5,
cex_inner=0.4)
celltalker::circos_plot(ligand_receptor_frame=top_stats,
cell_group_colors=colors_use,
ligand_color="blue",
receptor_color="red",
cex_outer=0.5,
cex_inner=0.4)
top_stats
results <- celltalker::celltalk(input_object=seuobj, metadata_grouping = 'CellType', ligand_receptor_pairs = celltalker::ramilowski_pairs,
number_cells_required = 100, min_expression = 1000, max_expression = 20000, 10)
results
top_stats <- results %>%
mutate(fdr=p.adjust(p_val,method="fdr")) %>%
filter(fdr<0.1) %>%
group_by(cell_type1) %>%
top_n(3,interact_ratio) %>%
ungroup()
topstats
topstq
top_stats
View(results)
View(results)
top_stats <- results %>%
mutate(fdr=p.adjust(p_val,method="fdr")) %>%
filter(fdr<0.5) %>%
group_by(cell_type1) %>%
top_n(3,interact_ratio) %>%
ungroup()
top_stats
top_stats <- results %>%
filter(p_val<0.05) %>%
group_by(cell_type1) %>%
top_n(3,interact_ratio) %>%
ungroup()
top_stats
colors_use <- scales::hue_pal()(length(unique(seuobj$CellType)))
celltalker::circos_plot(ligand_receptor_frame=top_stats,
cell_group_colors=colors_use,
ligand_color="blue",
receptor_color="red",
cex_outer=0.5,
cex_inner=0.4)
scales::hue_pal()
scales::hue_pal()(length(unique(seuobj$CellType)))
object[['original.project']]
perform.celltalker <- function(object, assay='RAW', slot='counts', clust.method, column,
number_cells_required = 100, min_expression = 1000,
max_expression = 20000, scramble_times = 10) {
if(!is(object = object, class2 = 'IBRAP')) {
stop('Object must be of class IBRAP\n')
}
if(!is.character(assay)) {
stop('Assay must be character string\n')
}
if(!assay %in% names(object@methods)) {
stop('Assay not contained in the supplied IBRAP object \n')
}
if(!is.character(assay)) {
stop('Slot must be character string\n')
}
if(!assay %in% c('counts','normalised','norm.scaled')) {
stop('Slot must either be: counts, normalised or norm.scaled. However, counts is highly recommended! \n')
}
if(!is.numeric(cores)) {
stop('cores must be a numerical value \n')
}
if(!is.character(clust.method)) {
stop('clust.method must be character string\n')
}
if(!is.character(column)) {
stop('column must be character string\n')
}
if(clust.method == 'metadata') {
if(!column %in% names(object@sample_metadata)) {
stop('specified column not contained in metadata \n')
}
} else if(!clust.method %in% names(object[[assay]]@cluster_assignments)) {
stop('could not find the clust.method, it must either be metadata or one of the cluster assignments dataframes stored in clister_assignments \n')
} else if(clust.method %in% names(object[[assay]]@cluster_assignments)) {
stop('specified column not contained in the supplied clusters_assignment \n')
}
if(clust.method == 'metadata') {
variable <- object[[column]]
} else {
variable <- object[[assay]]@cluster_assignments[[column]]
}
seuobj <- Seurat::CreateSeuratObject(counts = object[[assay]][[slot]])
seuobj$variable <- variable
if(slot == 'counts') {
seuobj@assays$RNA@data <- Seurat::LogNormalize(data = seuobj@assays$RNA@counts)
} else {
seuobj@assays$RNA@data <- object[[assay]][[slot]]
}
results <- celltalker::celltalk(input_object=seuobj, metadata_grouping = column, ligand_receptor_pairs = celltalker::ramilowski_pairs,
number_cells_required = number_cells_required, min_expression = min_expression, max_expression = max_expression,
scramble_times = scramble_times)
return(results)
}
obj[['CellType']]
obj[['CellTypes']]
obj@sample_metadata$CellTypes <- obj@sample_metadata$all_individual_samples.celseq.sample_metadata.celltype
obj@sample_metadata$CellTypes
perform.celltalker(object = obj, assay = 'SCT', slot = 'counts', clust.method = 'metadata', column = 'CellTypes')
library(tidyverse)
perform.celltalker <- function(object, assay='RAW', slot='counts', clust.method, column,
number_cells_required = 100, min_expression = 1000,
max_expression = 20000, scramble_times = 10) {
if(!is(object = object, class2 = 'IBRAP')) {
stop('Object must be of class IBRAP\n')
}
if(!is.character(assay)) {
stop('Assay must be character string\n')
}
if(!assay %in% names(object@methods)) {
stop('Assay not contained in the supplied IBRAP object \n')
}
if(!is.character(assay)) {
stop('Slot must be character string\n')
}
if(!slot %in% c('counts','normalised','norm.scaled')) {
stop('Slot must either be: counts, normalised or norm.scaled. However, counts is highly recommended! \n')
}
if(!is.numeric(cores)) {
stop('cores must be a numerical value \n')
}
if(!is.character(clust.method)) {
stop('clust.method must be character string\n')
}
if(!is.character(column)) {
stop('column must be character string\n')
}
if(clust.method == 'metadata') {
if(!column %in% names(object@sample_metadata)) {
stop('specified column not contained in metadata \n')
}
} else if(!clust.method %in% names(object[[assay]]@cluster_assignments)) {
stop('could not find the clust.method, it must either be metadata or one of the cluster assignments dataframes stored in clister_assignments \n')
} else if(clust.method %in% names(object[[assay]]@cluster_assignments)) {
stop('specified column not contained in the supplied clusters_assignment \n')
}
if(clust.method == 'metadata') {
variable <- object[[column]]
} else {
variable <- object[[assay]]@cluster_assignments[[column]]
}
seuobj <- Seurat::CreateSeuratObject(counts = object[[assay]][[slot]])
seuobj$variable <- variable
if(slot == 'counts') {
seuobj@assays$RNA@data <- Seurat::LogNormalize(data = seuobj@assays$RNA@counts)
} else {
seuobj@assays$RNA@data <- object[[assay]][[slot]]
}
results <- celltalker::celltalk(input_object=seuobj, metadata_grouping = column, ligand_receptor_pairs = celltalker::ramilowski_pairs,
number_cells_required = number_cells_required, min_expression = min_expression, max_expression = max_expression,
scramble_times = scramble_times)
return(results)
}
perform.celltalker(object = obj, assay = 'SCT', slot = 'counts', clust.method = 'metadata', column = 'CellTypes')
library(tidyverse)
perform.celltalker <- function(object, assay='RAW', slot='counts', clust.method, column,
number_cells_required = 100, min_expression = 1000,
max_expression = 20000, scramble_times = 10) {
if(!is(object = object, class2 = 'IBRAP')) {
stop('Object must be of class IBRAP\n')
}
if(!is.character(assay)) {
stop('Assay must be character string\n')
}
if(!assay %in% names(object@methods)) {
stop('Assay not contained in the supplied IBRAP object \n')
}
if(!is.character(assay)) {
stop('Slot must be character string\n')
}
if(!slot %in% c('counts','normalised','norm.scaled')) {
stop('Slot must either be: counts, normalised or norm.scaled. However, counts is highly recommended! \n')
}
if(!is.character(clust.method)) {
stop('clust.method must be character string\n')
}
if(!is.character(column)) {
stop('column must be character string\n')
}
if(clust.method == 'metadata') {
if(!column %in% names(object@sample_metadata)) {
stop('specified column not contained in metadata \n')
}
} else if(!clust.method %in% names(object[[assay]]@cluster_assignments)) {
stop('could not find the clust.method, it must either be metadata or one of the cluster assignments dataframes stored in clister_assignments \n')
} else if(clust.method %in% names(object[[assay]]@cluster_assignments)) {
stop('specified column not contained in the supplied clusters_assignment \n')
}
if(clust.method == 'metadata') {
variable <- object[[column]]
} else {
variable <- object[[assay]]@cluster_assignments[[column]]
}
seuobj <- Seurat::CreateSeuratObject(counts = object[[assay]][[slot]])
seuobj$variable <- variable
if(slot == 'counts') {
seuobj@assays$RNA@data <- Seurat::LogNormalize(data = seuobj@assays$RNA@counts)
} else {
seuobj@assays$RNA@data <- object[[assay]][[slot]]
}
results <- celltalker::celltalk(input_object=seuobj, metadata_grouping = column, ligand_receptor_pairs = celltalker::ramilowski_pairs,
number_cells_required = number_cells_required, min_expression = min_expression, max_expression = max_expression,
scramble_times = scramble_times)
return(results)
}
perform.celltalker(object = obj, assay = 'SCT', slot = 'counts', clust.method = 'metadata', column = 'CellTypes')
obj@sample_metadata$CellTypes <- obj@sample_metadata$all_individual_samples.celseq.sample_metadata.celltype
obj@sample_metadata$all_individual_samples.celseq.sample_metadata.celltype <- NULL
obj@sample_metadata$CellTypes
perform.celltalker(object = obj, assay = 'SCT', slot = 'counts', clust.method = 'metadata', column = 'CellTypes')
library(tidyverse)
perform.celltalker <- function(object, assay='RAW', slot='counts', clust.method, column,
number_cells_required = 100, min_expression = 1000,
max_expression = 20000, scramble_times = 10) {
if(!is(object = object, class2 = 'IBRAP')) {
stop('Object must be of class IBRAP\n')
}
if(!is.character(assay)) {
stop('Assay must be character string\n')
}
if(!assay %in% names(object@methods)) {
stop('Assay not contained in the supplied IBRAP object \n')
}
if(!is.character(assay)) {
stop('Slot must be character string\n')
}
if(!slot %in% c('counts','normalised','norm.scaled')) {
stop('Slot must either be: counts, normalised or norm.scaled. However, counts is highly recommended! \n')
}
if(!is.character(clust.method)) {
stop('clust.method must be character string\n')
}
if(!is.character(column)) {
stop('column must be character string\n')
}
if(clust.method == 'metadata') {
if(!column %in% names(object@sample_metadata)) {
stop('specified column not contained in metadata \n')
}
} else if(!clust.method %in% names(object[[assay]]@cluster_assignments)) {
stop('could not find the clust.method, it must either be metadata or one of the cluster assignments dataframes stored in clister_assignments \n')
} else if(clust.method %in% names(object[[assay]]@cluster_assignments)) {
stop('specified column not contained in the supplied clusters_assignment \n')
}
if(clust.method == 'metadata') {
variable <- object[[column]]
} else {
variable <- object[[assay]]@cluster_assignments[[column]]
}
seuobj <- Seurat::CreateSeuratObject(counts = object[[assay]][[slot]])
seuobj@meta.data[[column]] <- variable
if(slot == 'counts') {
seuobj@assays$RNA@data <- Seurat::LogNormalize(data = seuobj@assays$RNA@counts)
} else {
seuobj@assays$RNA@data <- object[[assay]][[slot]]
}
results <- celltalker::celltalk(input_object=seuobj, metadata_grouping = column, ligand_receptor_pairs = celltalker::ramilowski_pairs,
number_cells_required = number_cells_required, min_expression = min_expression, max_expression = max_expression,
scramble_times = scramble_times)
return(results)
}
perform.celltalker(object = obj, assay = 'SCT', slot = 'counts', clust.method = 'metadata', column = 'CellTypes')
perform.slingshot.trajectory(object = object, reduction = 'PCA_UMAP', assay = 'SCT', clust.method = 'metadata', column = 'CellTypes', verbose = T)
object
object@methods$SCT@visualisation_reductions
obj@methods$SCT@visualisation_reductions
obj <- perform.umap(object = obj, assay = c('SCT','SCRAN','SCANPY'), reduction = 'PCA', dims.use = list(10), verbose = T)
perform.slingshot.trajectory(object = object, reduction = 'PCA_UMAP', assay = 'SCT', clust.method = 'metadata', column = 'CellTypes', verbose = T)
perform.slingshot.trajectory(object = obj, reduction = 'PCA_UMAP', assay = 'SCT', clust.method = 'metadata', column = 'CellTypes', verbose = T)
res <- slingshot::slingshot(data = obj@methods$SCT@visualisation_reductions$PCA_UMAP, clusterLabels = obj@sample_metadata$CellTypes, start.clus = NULL, end.clus = NULL)
res <- slingshot::slingshot(data = obj@methods$SCT@visualisation_reductions$PCA_UMAP, clusterLabels = obj@sample_metadata$CellTypes)
res <- slingshot::slingshot(data = obj@methods$SCT@visualisation_reductions$PCA_UMAP, clusterLabels = obj@sample_metadata$CellTypes)
obj@methods$SCT@visualisation_reductions$PCA_UMAP
obj
showObjectContents(obj, assay = 'SCT')
res <- slingshot::slingshot(data = obj@methods$SCT@visualisation_reductions$PCA_UMAP, clusterLabels = obj@methods$)
res <- slingshot::slingshot(data = obj@methods$SCT@visualisation_reductions$PCA_UMAP, clusterLabels = obj@methods$SCT@cluster_assignments$`PCA_NN:LOUVAIN`$res_0.3)
res
colData(res)
library(slingshot)
colData(res)
res
cellData(res)
res <- slingshot::slingshot(data = obj@methods$SCT@visualisation_reductions$PCA_UMAP, clusterLabels = as.factor(obj@sample_metadata$CellTypes))
obj@sample_metadata$CellTypes
unique(obj@sample_metadata$CellTypes)
res
plot.slingshot(result = res, clusters = obj[['SCT']][['PCA_NN:LOUVAIN']][['res_0.8']])
res
class(res)
library(RaceID)
sc <- SCseq(intestinalData)
install.packages("RaceID")
library(RaceID)
sc <- SCseq(intestinalData)
sc
all_individual_samples <- readRDS("~/work/Results/scRNA-seq/IBRAP_publication/all_individual_samples.rds")
pt <- slingshot::slingPseudotime(res)
obj
prepare.for.dittoSeq(object = obj, assay = 'SCT', slot = 'normalised', clust.method = 'PCA_NN:LOUVAIN', column = 'res_0.8', reduction = 'PCA_UMAP')
obj <- prepare.for.dittoSeq(object = obj, assay = 'SCT', slot = 'normalised', clust.method = 'PCA_NN:LOUVAIN', column = 'res_0.8', reduction = 'PCA_UMAP')
object
showObjectContents(object,'SCT')
scater::aggregateAcrossCells(x = obj, colData('res_0.8'))
scater::aggregateAcrossCells(x = obj, colData(obj,'res_0.8'))
obj
scater::aggregateAcrossCells(x = obj, colLabels(obj,'res_0.8'))
scater::aggregateAcrossCells(x = obj, colLabels(obj))
colLabels(obj)
colLabels(obj) <- colnames(obj)
scater::aggregateAcrossCells(x = obj, colLabels(obj))
colLabels(obj)
roxygen2::roxygenise()
getwd()
obj
object
saveRDS(object, 'celseq_test.rds')
