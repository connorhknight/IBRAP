}
}
if(!is.null(vars.to.regress)) {
if(!is.character(vars.to.regress)) {
stop('vars.to.regress must be character string\n')
}
}
if(!is.logical(do.scale)) {
stop('do.scale must be logical: TRUE/FALSE\n')
}
if(!is.logical(do.center)) {
stop('do.center must be logical: TRUE/FALSE\n')
}
sc <- reticulate::import('scanpy')
scobj <- sc$AnnData(X = t(as.matrix(object@methods[[assay]][[slot]])))
scobj$obs_names <- as.factor(colnames(object@methods[[assay]][[slot]]))
scobj$var_names <- as.factor(rownames(object@methods[[assay]][[slot]]))
if(length(names(object@sample_metadata)) >= 1) {
scobj$obs <- object@sample_metadata
}
cat(crayon::cyan(paste0(Sys.time(), ': normalising counts\n')))
if(!is.null(target_sum) & !is.null(key_added)) {
sc$pp$normalize_total(adata = scobj, target_sum = as.integer(target_sum),
exclude_highly_expressed = as.logical(exclude_highly_expressed),
max_fraction = as.integer(max_fraction), key_added = as.character(key_added))
} else if (!is.null(target_sum)) {
sc$pp$normalize_total(adata = scobj, target_sum = as.integer(target_sum),
exclude_highly_expressed = as.logical(exclude_highly_expressed),
max_fraction = as.integer(max_fraction))
} else if (!is.null(key_added)) {
sc$pp$normalize_total(adata = scobj,  target_sum=target_sum,
exclude_highly_expressed = as.logical(exclude_highly_expressed),
max_fraction = as.integer(max_fraction))
} else {
sc$pp$normalize_total(adata = scobj, target_sum=target_sum)
}
.counts <- t(scobj$X)
rownames(.counts) <- rownames(object)
colnames(.counts) <- colnames(object)
feat.metadata <- feature_metadata(assay = .counts, col.prefix = 'SCANPY')
cat(crayon::cyan(paste0(Sys.time(), ': log transforming data\n')))
if(isTRUE(log1)) {
sc$pp$log1p(scobj)
} else if(isFALSE(log1)) {
scobj$X <- log2(scobj$X+1)
}
.normalised <- t(scobj$X)
rownames(.normalised) <- rownames(object@methods$RAW@counts)
colnames(.normalised) <- colnames(object@methods$RAW@counts)
cat(crayon::cyan(paste0(Sys.time(), ': computing highly variable genes\n')))
if (!is.null(n_top_genes) & !is.null(batch_key)) {
sc$pp$highly_variable_genes(adata = scobj,
n_top_genes = as.integer(n_top_genes),
min_mean = as.integer(min_mean),
max_mean = as.integer(max_mean),
min_disp = as.integer(min_disp),
span = as.integer(span),
n_bins = as.integer(n_bins),
flavor = as.character(flavor),
batch_key = as.character(batch_key))
} else if (!is.null(n_top_genes)) {
sc$pp$highly_variable_genes(adata = scobj,
n_top_genes = as.integer(n_top_genes),
min_mean = as.integer(min_mean),
max_mean = as.integer(max_mean),
min_disp = as.integer(min_disp),
span = as.integer(span),
n_bins = as.integer(n_bins),
flavor = as.character(flavor))
} else if (!is.null(batch_key)) {
sc$pp$highly_variable_genes(adata = scobj,
min_mean = as.integer(min_mean),
max_mean = as.integer(max_mean),
min_disp = as.integer(min_disp),
span = as.integer(span),
n_bins = as.integer(n_bins),
flavor = as.character(flavor))
} else {
sc$pp$highly_variable_genes(adata = scobj,
min_mean = as.integer(min_mean),
max_mean = as.integer(max_mean),
min_disp = as.integer(min_disp),
span = as.integer(span),
n_bins = as.integer(n_bins),
flavor = as.character(flavor))
}
.highly.variable.genes <- rownames(object@methods$RAW@counts)[scobj$var[['highly_variable']]]
scobj2 <- sc$AnnData(X = t(.normalised[scobj$var$highly_variable,]))
pd <- reticulate::import('pandas')
scobj2$var_names <- as.factor(rownames(object@methods$RAW@counts)[scobj$var$highly_variable])
scobj2$obs_names <- as.factor(colnames(object@methods$RAW@counts))
if(length(vars.to.regress) > 1) {
scobj2$obs <- pd$DataFrame(data = as.data.frame(object@sample_metadata[,vars.to.regress]))
} else {
scobj2$obs[,vars.to.regress] <- pd$DataFrame(data = as.data.frame(object@sample_metadata[,vars.to.regress]))
}
cat(crayon::cyan(paste0(Sys.time(), ': regressing covaraites \n')))
sc$pp$regress_out(adata = scobj2, keys = vars.to.regress)
cat(crayon::cyan(paste0(Sys.time(), ': scaling data \n')))
sc$pp$scale(scobj2)
.norm.scaled <- t(scobj2$X)
colnames(.norm.scaled) <- colnames(object@methods$RAW@counts)
rownames(.norm.scaled) <- .highly.variable.genes
object@sample_metadata <- cbind(object@sample_metadata, cell_metadata(assay = as.matrix(.normalised), col.prefix = paste0('SCANPY', new.assay.suffix)))
if('_' %in% unlist(strsplit(x = new.assay.suffix, split = ''))) {
cat(crayon::cyan(paste0(Sys.time(), ': _ cannot be used in new.assay.suffix, replacing with - \n')))
new.assay.suffix <- sub(pattern = '_', replacement = '-', x = new.assay.suffix)
}
object@methods[[paste0('SCANPY', new.assay.suffix)]] <- new(Class = 'methods',
counts = as(.counts, 'dgCMatrix'),
normalised = as(.normalised, 'dgCMatrix'),
norm.scaled = as.matrix(.norm.scaled),
highly.variable.genes = .highly.variable.genes,
feature_metadata = feat.metadata)
cat(crayon::cyan(paste0(Sys.time(), ': Scanpy normalisation completed \n')))
return(object)
}
celseq2 <- perform.scanpy(object = celseq2,
vars.to.regress = 'RAW_total.counts', do.scale = T)
celseq2 <- perform.pca(object = celseq2,
assay = c('SCANPY'),
n.pcs = 50, reduction.save = 'pca')
celseq2 <- perform.nn(object = celseq2,
assay = c('SCANPY'),
reduction = c('pca'),
dims = list(10))
celseq2 <- perform.nn(object = celseq2,
assay = c('SCANPY'),
reduction = c('pca'),
dims = list(15))
celseq2 <- perform.umap(object = celseq2,
assay = c('SCANPY'),
graph = c('pca_nn'),
n_components = 2)
plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.1)
plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5)
plot.reduced.dim.interactive(object = celseq2,
reduction = 'pca_nn:umap',
assay = 'SCANPY',
clust.method = 'metadata',
column = 'celltype', pt.size = 0.6, dimensions = 2)
plot.reduced.dim.interactive(object = celseq2,
reduction = 'pca_nn:umap',
assay = 'SCANPY',
clust.method = 'metadata',
column = 'celltype', dimensions = 2)
plot.features(object = celseq2, assay = 'SCANPY', slot = 'norm.scaled', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5)
plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5, percentile = 0.1-0.9)
plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5, percentile = c(0.1-0.9))
plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5, percentile = c(0.1-0.9))
percentile = c(0.1-0.9)
plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5, percentile = c(0.1:0.9))
c(0.1:0.9)
plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5)
c(0,1)
features = 'GCG'
reduction = 'pca_nn:umap'
slot = 'normalised'
assay = 'SCANPY'
object = celseq2
x <- 'GCG'
results <- as.data.frame(object@methods[[assay]]@visualisation_reductions[[reduction]])[,1:2]
orig.colnames <- colnames(object@methods[[assay]]@visualisation_reductions[[reduction]][,1:2])
colnames(results) <- c('red_1', 'red_2')
iso <- object@methods[[assay]][[slot]][x,]
results[,x] <- iso
colnames(results)[3] <- 'feature'
lower <- as.numeric(quantile(results$feature, percentile)[1])
quantile(x = results$feature)
quantile(x = results$feature, probs = c(0.1:0.9))
quantile(x = results$feature, probs = c(0.1,0.9))
plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5, percentile = c(0.1,0.9))
plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5, percentile = c(0.7,0.9))
order(factor(results$feature))
order(-as.numeric(factor(results$feature)))
order(-as.numeric(factor(factor(results$feature))))
slot
iso <- object@methods[[assay]][[slot]][x,]
iso
results[,x] <- iso
colnames(results)[3] <- 'feature'
results
results$feature
factor(results$feature)
order(factor(results$feature))
order(-factor(results$feature))
results[order(-as.numeric(results$featurel))),]
results[order(-as.numeric(results$feature))),]
results[order(-as.numeric(results$feature)),]
results[order(as.numeric(results$feature)),]
#' @name plot.features
#' @aliases plot.features
#'
#' @title Plot of reduced dimensions and features
#'
#' @param object An IBRAP S4 class object
#' @param assay Character. Which assay within the object to access
#' @param slot Character. Which expression matrix would you like to access. Default = 'normalised'
#' @param reduction Character. Which reduction should be used for the plot
#' @param features Character Which features should be plotted
#' @param pt_size Numeric. what size should the inidividual plot sizes be
#' @param cells Numeric. Which cells should be subset for plotting, Default = NULL
#'
#' @return A plot of reduced dimensions annotated with assignments
#'
#' @export plot.features
plot.features <- function(object,
assay,
slot,
reduction,
features,
order = TRUE,
percentile = c(0,1),
pt_size = 3,
cells = NULL) {
if(!is(object = object, class2 = 'IBRAP')) {
stop('object must be of class IBRAP\n')
}
if(!is.character(reduction)) {
stop('reduction must be character string\n')
}
if(!assay %in% names(object@methods)) {
stop('assay does not exist\n')
}
if(!reduction %in% names(c(object@methods[[assay]]@computational_reductions,
object@methods[[assay]]@visualisation_reductions,
object@methods[[assay]]@integration_reductions))) {
stop('reduction does not exist\n')
}
if(!is.character(features)) {
stop('features must be character string \n')
}
ggarrange.tmp <- function(...) {
egg::ggarrange(...)
}
plot.list <- list()
for(x in features) {
results <- as.data.frame(object@methods[[assay]]@visualisation_reductions[[reduction]])[,1:2]
orig.colnames <- colnames(object@methods[[assay]]@visualisation_reductions[[reduction]][,1:2])
if(is.null(object@methods[[assay]][[slot]][x,])) {
cat(crayon::cyan(paste0(Sys.time(), ': feature ', x, ' was not present in the defined assay, resorting to counts matrix', '\n')))
iso <- object@methods[[1]]@counts[x,]
} else {
iso <- object@methods[[assay]][[slot]][x,]
}
colnames(results) <- c('red_1', 'red_2')
results[,x] <- iso
colnames(results)[3] <- 'feature'
if(!is.null(cells)) {
results <- results[cells,]
}
if(isTRUE(order)) {
results <- results[order(as.numeric(results$feature)),]
}
lower <- as.numeric(quantile(results$feature, percentile)[1])
upper <- as.numeric(quantile(results$feature, percentile)[2])
results <- subset(x = results, results$feature >= lower & results$feature <= upper)
plot.list[[x]] <- ggplot2::ggplot(data = results[order(results$feature),],
ggplot2::aes(x = red_1, y = red_2)) +
ggplot2::geom_point(ggplot2::aes(color=feature), size = pt_size)+
ggplot2::scale_color_gradient(low = '#C0C0C0', high = '#4169E1') +
ggplot2::theme_classic() + ggplot2::labs(title=x, x=orig.colnames[1], y=orig.colnames[2]) +
ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, face = 'bold', size = 20))
}
is.even <- function(x) {
if(as.integer(x %% 2) == 0) {
return(TRUE)
} else {
return(FALSE)
}
}
if(!is.even(length(plot.list))) {
plot.list[length(plot.list)+1] <- plot.list[1] + ggplot2::geom_blank()
}
if(length(plot.list) > 1){
if(length(plot.list) <3) {
do.call('ggarrange.tmp', c(plots = plot.list, ncol = 1, nrow = 2))
} else if(length(plot.list) <5) {
do.call('ggarrange.tmp', c(plots = plot.list, ncol = 2, nrow = 2))
} else if(length(plot.list) <7) {
do.call('ggarrange.tmp', c(plots = plot.list, ncol = 3, nrow = 2))
} else {
do.call('ggarrange.tmp', c(plots = plot.list))
}
} else {
plot.list[1]
}
}
rm(assay,features,iso,orig.colnames,percentile,reduction,slot,x)
#' @name plot.features
#' @aliases plot.features
#'
#' @title Plot of reduced dimensions and features
#'
#' @param object An IBRAP S4 class object
#' @param assay Character. Which assay within the object to access
#' @param slot Character. Which expression matrix would you like to access. Default = 'normalised'
#' @param reduction Character. Which reduction should be used for the plot
#' @param features Character Which features should be plotted
#' @param order Boolean. Should datapoints be plotted in order of expression intensity. Default = TRUE
#' @param pt_size Numeric. what size should the inidividual plot sizes be
#' @param cells Numeric. Which cells should be subset for plotting, Default = NULL
#'
#' @return A plot of reduced dimensions annotated with assignments
#'
#' @export plot.features
plot.features <- function(object,
assay,
slot,
reduction,
features,
order = TRUE,
percentile = c(0,1),
pt_size = 3,
cells = NULL) {
if(!is(object = object, class2 = 'IBRAP')) {
stop('object must be of class IBRAP\n')
}
if(!is.character(reduction)) {
stop('reduction must be character string\n')
}
if(!assay %in% names(object@methods)) {
stop('assay does not exist\n')
}
if(!reduction %in% names(c(object@methods[[assay]]@computational_reductions,
object@methods[[assay]]@visualisation_reductions,
object@methods[[assay]]@integration_reductions))) {
stop('reduction does not exist\n')
}
if(!is.character(features)) {
stop('features must be character string \n')
}
ggarrange.tmp <- function(...) {
egg::ggarrange(...)
}
plot.list <- list()
for(x in features) {
results <- as.data.frame(object@methods[[assay]]@visualisation_reductions[[reduction]])[,1:2]
orig.colnames <- colnames(object@methods[[assay]]@visualisation_reductions[[reduction]][,1:2])
if(is.null(object@methods[[assay]][[slot]][x,])) {
cat(crayon::cyan(paste0(Sys.time(), ': feature ', x, ' was not present in the defined assay, resorting to counts matrix', '\n')))
iso <- object@methods[[1]]@counts[x,]
} else {
iso <- object@methods[[assay]][[slot]][x,]
}
colnames(results) <- c('red_1', 'red_2')
results[,x] <- iso
colnames(results)[3] <- 'feature'
if(!is.null(cells)) {
results <- results[cells,]
}
if(isTRUE(order)) {
results <- results[order(as.numeric(results$feature)),]
}
lower <- as.numeric(quantile(results$feature, percentile)[1])
upper <- as.numeric(quantile(results$feature, percentile)[2])
results <- subset(x = results, results$feature >= lower & results$feature <= upper)
plot.list[[x]] <- ggplot2::ggplot(data = results[order(results$feature),],
ggplot2::aes(x = red_1, y = red_2)) +
ggplot2::geom_point(ggplot2::aes(color=feature), size = pt_size)+
ggplot2::scale_color_gradient(low = '#C0C0C0', high = '#4169E1') +
ggplot2::theme_classic() + ggplot2::labs(title=x, x=orig.colnames[1], y=orig.colnames[2]) +
ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, face = 'bold', size = 20))
}
is.even <- function(x) {
if(as.integer(x %% 2) == 0) {
return(TRUE)
} else {
return(FALSE)
}
}
if(!is.even(length(plot.list))) {
plot.list[length(plot.list)+1] <- plot.list[1] + ggplot2::geom_blank()
}
if(length(plot.list) > 1){
if(length(plot.list) <3) {
do.call('ggarrange.tmp', c(plots = plot.list, ncol = 1, nrow = 2))
} else if(length(plot.list) <5) {
do.call('ggarrange.tmp', c(plots = plot.list, ncol = 2, nrow = 2))
} else if(length(plot.list) <7) {
do.call('ggarrange.tmp', c(plots = plot.list, ncol = 3, nrow = 2))
} else {
do.call('ggarrange.tmp', c(plots = plot.list))
}
} else {
plot.list[1]
}
}
plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5)
plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5, order = T, percentile = c(0.1,0.9))
plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5)
#' @name plot.features
#' @aliases plot.features
#'
#' @title Plot of reduced dimensions and features
#'
#' @param object An IBRAP S4 class object
#' @param assay Character. Which assay within the object to access
#' @param slot Character. Which expression matrix would you like to access. Default = 'normalised'
#' @param reduction Character. Which reduction should be used for the plot
#' @param features Character Which features should be plotted
#' @param order Boolean. Should datapoints be plotted in order of expression intensity. Default = TRUE
#' @param percentile. Numerical. What percentile of datapoint expression should be plotted. Default = c(0.1,0.9)
#' @param pt_size Numeric. what size should the inidividual plot sizes be
#' @param cells Numeric. Which cells should be subset for plotting, Default = NULL
#'
#' @return A plot of reduced dimensions annotated with assignments
#'
#' @export plot.features
plot.features <- function(object,
assay,
slot,
reduction,
features,
order = TRUE,
percentile = c(0.1,0.9),
pt_size = 3,
cells = NULL) {
if(!is(object = object, class2 = 'IBRAP')) {
stop('object must be of class IBRAP\n')
}
if(!is.character(reduction)) {
stop('reduction must be character string\n')
}
if(!assay %in% names(object@methods)) {
stop('assay does not exist\n')
}
if(!reduction %in% names(c(object@methods[[assay]]@computational_reductions,
object@methods[[assay]]@visualisation_reductions,
object@methods[[assay]]@integration_reductions))) {
stop('reduction does not exist\n')
}
if(!is.character(features)) {
stop('features must be character string \n')
}
ggarrange.tmp <- function(...) {
egg::ggarrange(...)
}
plot.list <- list()
for(x in features) {
results <- as.data.frame(object@methods[[assay]]@visualisation_reductions[[reduction]])[,1:2]
orig.colnames <- colnames(object@methods[[assay]]@visualisation_reductions[[reduction]][,1:2])
if(is.null(object@methods[[assay]][[slot]][x,])) {
cat(crayon::cyan(paste0(Sys.time(), ': feature ', x, ' was not present in the defined assay, resorting to counts matrix', '\n')))
iso <- object@methods[[1]]@counts[x,]
} else {
iso <- object@methods[[assay]][[slot]][x,]
}
colnames(results) <- c('red_1', 'red_2')
results[,x] <- iso
colnames(results)[3] <- 'feature'
if(!is.null(cells)) {
results <- results[cells,]
}
if(isTRUE(order)) {
results <- results[order(as.numeric(results$feature)),]
}
lower <- as.numeric(quantile(results$feature, percentile)[1])
upper <- as.numeric(quantile(results$feature, percentile)[2])
results <- subset(x = results, results$feature >= lower & results$feature <= upper)
plot.list[[x]] <- ggplot2::ggplot(data = results[order(results$feature),],
ggplot2::aes(x = red_1, y = red_2)) +
ggplot2::geom_point(ggplot2::aes(color=feature), size = pt_size)+
ggplot2::scale_color_gradient(low = '#C0C0C0', high = '#4169E1') +
ggplot2::theme_classic() + ggplot2::labs(title=x, x=orig.colnames[1], y=orig.colnames[2]) +
ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, face = 'bold', size = 20))
}
is.even <- function(x) {
if(as.integer(x %% 2) == 0) {
return(TRUE)
} else {
return(FALSE)
}
}
if(!is.even(length(plot.list))) {
plot.list[length(plot.list)+1] <- plot.list[1] + ggplot2::geom_blank()
}
if(length(plot.list) > 1){
if(length(plot.list) <3) {
do.call('ggarrange.tmp', c(plots = plot.list, ncol = 1, nrow = 2))
} else if(length(plot.list) <5) {
do.call('ggarrange.tmp', c(plots = plot.list, ncol = 2, nrow = 2))
} else if(length(plot.list) <7) {
do.call('ggarrange.tmp', c(plots = plot.list, ncol = 3, nrow = 2))
} else {
do.call('ggarrange.tmp', c(plots = plot.list))
}
} else {
plot.list[1]
}
}
plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5)
fig1 <- plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5)
fig2 <- plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'GCG', pt_size = 0.5, order = T, percentile = c(0.1,0.9))
fig1 + fig2
fig1
fig2
fig2 <- plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'INS', pt_size = 0.5, order = T, percentile = c(0.1,0.9))
plot.features(object = celseq2, assay = 'SCANPY', slot = 'normalised', reduction = 'pca_nn:umap', features = 'INS', pt_size = 0.5, order = T, percentile = c(0.1,0.9))
getwd()
roxygen2::roxygenise
roxygen2::roxygenise()
devtools::install_github(repo = 'connorhknight/IBRAP')
?Seurat::RunUMAP()
getwd()
pkgdown::build_site
pkgdown::build_site()
?rmarkdown::render
getwd()
?rmarkdown::render
rmarkdown::render(input = 'index.Rmd', output_format = 'html_document')
pkgdown::build_site()
