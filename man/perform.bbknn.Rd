% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/perform.bbknn.R
\name{perform.bbknn}
\alias{perform.bbknn}
\title{Performs BBKNN integration}
\usage{
perform.bbknn(
  object,
  assay,
  reduction,
  graph.name.suffix = "",
  batch,
  approx = FALSE,
  metric = "euclidean",
  neighbors_within_batch = 3,
  n_pcs = NULL,
  trim = NULL,
  n_trees = 10,
  use_faiss = TRUE,
  set_op_mix_ratio = 1,
  local_connectivity = 1,
  generate.diffmap = FALSE,
  n_comps = 15,
  diffmap.name.suffix = ""
)
}
\arguments{
\item{object}{IBRAP S4 class object}

\item{assay}{Character. String containing indicating which assay to use}

\item{reduction}{Character. String defining the name of the reduction to provide for BBKNN. Default = NULL}

\item{graph.name.suffix}{Character. Should a suffix be added to the end of bbknn as the graph name, i.e. parameter changes?}

\item{batch}{Character. Column name in metadata indicating batch. Can be multiple.}

\item{approx}{Character. Employs annoy's approximate neighbour finding. Useful for large datasets but may increase correction.}

\item{neighbors_within_batch}{Numerical. How many neighbours to report per batch. Default = 3}

\item{n_pcs}{Numerical. Range of principal components to use. Default = NULL}

\item{trim}{Numerical. Trims the n of neighbours per cell to this value. Helps with population independence. Default = NULL}

\item{n_trees}{Numerical. Number of trees to generate in annoy forest. More trees provides higher precision at the cost of increased resource demand and run time. Default = 10}

\item{use_faiss}{Boolean. Uses faiss package to compute nearest neighbour, this improves run time at the cost of precision. Default = TRUE}

\item{set_op_mix_ratio}{Numerical. UMAP connectivity parameter between 0 and 1. controls the blen d between a connectivity matrix formed exclusively from mutual nearest neighbour pairs (0) and a union of all observed neighbour relationships with the mutual pairs emphasised (1). Default = 1.0}

\item{local_connectivity}{Numerical. How many nearest neighbours of each cell are assumed to be fully connected. Default = 1}

\item{generate.diffmap}{Boolean. Should diffusion maps be generated from the neighourhood graphs, these will be stored in computational_reductions and can be used for umap generation and further neighbourhood generation. Default = TRUE}

\item{n_comps}{Numerical. How many components should be generated for the diffusion maps. Default = 15}

\item{metric.}{Character. Which distance metric to use when approx is TRUE, options: 'angular', 'euclidean', 'manhattan' or 'hamming'. Default = 'euclidean'}

\item{diffmap.name.sufix}{Character. Should a suffix be added to the end of bbknn:diffmap as the reduction name, i.e. parameter changes?}
}
\value{
BBKNN connectivity graph contained in graphs in the indicated method-assays
}
\description{
Performs BBKNN integration on defined method-assays and reductions contained within. This is performed on reductions.
}
\examples{

# This example will generate a diffusion map as well 
object <- perform.bbknn(object = object, 
                        assay = c('SCT', 'SCANPY', 'SCRAN'), 
                        reduction = c('pca'),
                        batch = 'tech', generate.diffmap = T)
                          
#' # This example will generate a diffusion map as well 
object <- perform.bbknn(object = object, 
                        assay = c('SCT', 'SCANPY', 'SCRAN'), 
                        reduction = c('pca'),
                        batch = 'tech')
                        
}
