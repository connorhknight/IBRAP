% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/find_neighbours.R
\name{perform.nn}
\alias{perform.nn}
\title{Finds the shared nearest neighbourhood for the cells. This supplies a graph.}
\usage{
perform.nn(
  object,
  assay,
  reduction,
  neighbour.name.suffix = "",
  dims = 0,
  k.param = 20,
  prune.SNN = 1/15,
  nn.method = "annoy",
  n.trees = 50,
  nn.eps = 0,
  annoy.metric = "euclidean",
  n_neighbors = 15,
  random_state = 0,
  method = "umap",
  metric = "euclidean",
  generate.diffmap = FALSE,
  n_comps = 15,
  diffmap.name.suffix = ""
)
}
\arguments{
\item{object}{IBRAP S4 class object}

\item{assay}{Character. String containing indicating which assay to use}

\item{reduction}{Character. String defining which reduction to supply to the clustering algorithm.}

\item{neighbour.name.suffix}{Character. String defining the names to store the neighbourhood graph results under.}

\item{dims}{Numerical. (scanpy only) How many components of the reduction should be used, 0 means that all will be used. Default = 0}

\item{k.param}{Numerical. The number of k when calcuating k-nearest neighbour. Default = 20}

\item{prune.SNN}{Numerical. Setas acceptance cutoff for jaccard index whilst computing neighbourhood overlap for SNN construction. Any edges with a value less than this parameter will be removed. 0 = no pruning and 1 = prune everything. Default = 0}

\item{nn.method}{Character. Nearest neighbour method, either 'rann' or 'annoy'. Default = 'annoy'}

\item{n.trees}{Numerical. More trees facilitates hgiher precision when using 'annoy' method. Default = 20}

\item{nn.eps}{Numerical. Margin of error when performing nearest neighbour search whilst using rann method. 0 would imply an exact search. Default = 0.0}

\item{annoy.metric}{Character. Distance metric for annoy method. Options: 'euclidean', 'cosine', 'manhattan', 'hamming'. Default = 'euclidean'}

\item{n_neighbors}{Numerical. (scanpy only) How many neighbours should be found per cell, a higher value typically achieves more accurate results. Default = 15}

\item{random_state}{Numerical. (scanpy only) The seed value to use. Default = 0}

\item{method}{Character. (scanpy only) String indicating which methodology to use including: ‘umap’, ‘gauss’ or ‘rapids’}

\item{metric}{Character. (scanpy only) String indicating which distance metric to use, including: ‘braycurtis’, ‘canberra’, ‘chebyshev’, ‘correlation’, ‘dice’, ‘hamming’, ‘jaccard’, ‘kulsinski’, ‘mahalanobis’, ‘minkowski’, ‘rogerstanimoto’, ‘russellrao’, ‘seuclidean’, ‘sokalmichener’, ‘sokalsneath’, ‘sqeuclidean’, ‘yule’, ‘cityblock’, ‘cosine’, ‘euclidean’, ‘l1’, ‘l2’ or ‘manhattan’}

\item{generate.diffmap}{Boolean. (scanpy only) Should diffusion maps be generated from the neighourhood graphs, these will be stored in computational_reductions and can be used for umap generation and further neighbourhood generation. Default = TRUE}

\item{n_comps}{Numerical. (scanpy only) How many components should be generated for the diffusion maps. Default = 15}

\item{compute.SNN}{Boolean. Should the shared nearest neighbour graph be calculated. Default = TRUE}

\item{diffmap.name}{Character. (scanpy only) What should the diffusion maps be named.}
}
\description{
Neighbourhood graph generator utilised. According to the assay name a different method will be used. If the assay is derived from scanpy then the scanpy algorithm will be applied. Otherwise, the seurat implementation will be applied.
}
\examples{

# generates a diffusion map from the scanpy assay
object <- perform.nn(object = object, assay = c('SCT', 'SCRAN', 'SCANPY'), 
                     reduction = c('pca'),
                     dims = list(0,0))
                        

}
